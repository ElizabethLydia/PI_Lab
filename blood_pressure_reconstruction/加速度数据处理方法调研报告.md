# åŠ é€Ÿåº¦æ•°æ®å¤„ç†æ–¹æ³•è°ƒç ”æŠ¥å‘Š

## ğŸ“Š åŠ é€Ÿåº¦æ•°æ®åœ¨PPGä¿¡å·å¤„ç†ä¸­çš„é‡è¦æ€§

### 1. **è¿åŠ¨ä¼ªå½±çš„æ¥æº**
- **èº«ä½“è¿åŠ¨**: èµ°è·¯ã€è·‘æ­¥ã€æ‰‹åŠ¿ç­‰
- **è®¾å¤‡æŠ–åŠ¨**: ä¼ æ„Ÿå™¨æ¾åŠ¨ã€æŒ¯åŠ¨
- **ç¯å¢ƒå¹²æ‰°**: è½¦è¾†éœ‡åŠ¨ã€æœºæ¢°æŒ¯åŠ¨
- **å‘¼å¸è¿åŠ¨**: èƒ¸éƒ¨èµ·ä¼ã€è…¹éƒ¨è¿åŠ¨

### 2. **åŠ é€Ÿåº¦æ•°æ®çš„ä½œç”¨**
- **è¿åŠ¨æ£€æµ‹**: è¯†åˆ«è¿åŠ¨æ®µå’Œé™æ­¢æ®µ
- **ä¼ªå½±å»é™¤**: åŸºäºè¿åŠ¨ä¿¡æ¯å»é™¤å™ªå£°
- **ä¿¡å·è´¨é‡è¯„ä¼°**: è¯„ä¼°PPGä¿¡å·çš„å¯ä¿¡åº¦
- **æ´»åŠ¨åˆ†ç±»**: åŒºåˆ†ä¸åŒç±»å‹çš„è¿åŠ¨

## ğŸ” åŠ é€Ÿåº¦æ•°æ®å¤„ç†æ–¹æ³•è¯¦è§£

### 1. **è¿åŠ¨æ£€æµ‹æ–¹æ³•**

#### **é˜ˆå€¼æ£€æµ‹æ³•**
```python
def threshold_detection(acc_data, threshold_factor=2.0):
    """
    åŸºäºé˜ˆå€¼çš„è¿åŠ¨æ£€æµ‹
    
    åŸç†: è®¡ç®—åŠ é€Ÿåº¦å¹…å€¼ï¼Œè¶…è¿‡é˜ˆå€¼çš„æ®µè®¤ä¸ºæ˜¯è¿åŠ¨æ®µ
    ä¼˜ç‚¹: ç®€å•å¿«é€Ÿï¼Œè®¡ç®—é‡å°
    ç¼ºç‚¹: é˜ˆå€¼å›ºå®šï¼Œé€‚åº”æ€§å·®
    """
    # è®¡ç®—åŠ é€Ÿåº¦å¹…å€¼
    acc_magnitude = np.sqrt(acc_data['ax']**2 + acc_data['ay']**2 + acc_data['az']**2)
    
    # è®¡ç®—é˜ˆå€¼
    threshold = np.mean(acc_magnitude) + threshold_factor * np.std(acc_magnitude)
    
    # åˆ›å»ºè¿åŠ¨æ©ç 
    motion_mask = acc_magnitude > threshold
    
    return motion_mask, acc_magnitude
```

#### **æ»‘åŠ¨çª—å£æ£€æµ‹æ³•**
```python
def sliding_window_detection(acc_data, window_size=100, threshold_factor=1.5):
    """
    æ»‘åŠ¨çª—å£è¿åŠ¨æ£€æµ‹
    
    åŸç†: ä½¿ç”¨æ»‘åŠ¨çª—å£è®¡ç®—å±€éƒ¨ç»Ÿè®¡é‡ï¼ŒåŠ¨æ€è°ƒæ•´é˜ˆå€¼
    ä¼˜ç‚¹: è‡ªé€‚åº”é˜ˆå€¼ï¼Œé€‚åº”ä¿¡å·å˜åŒ–
    ç¼ºç‚¹: è®¡ç®—é‡è¾ƒå¤§ï¼Œéœ€è¦è°ƒå‚
    """
    acc_magnitude = np.sqrt(acc_data['ax']**2 + acc_data['ay']**2 + acc_data['az']**2)
    
    # åŠ¨æ€é˜ˆå€¼
    acc_threshold = np.zeros_like(acc_magnitude)
    for i in range(len(acc_magnitude)):
        start_idx = max(0, i - window_size // 2)
        end_idx = min(len(acc_magnitude), i + window_size // 2)
        local_mean = np.mean(acc_magnitude[start_idx:end_idx])
        local_std = np.std(acc_magnitude[start_idx:end_idx])
        acc_threshold[i] = local_mean + threshold_factor * local_std
    
    motion_mask = acc_magnitude > acc_threshold
    return motion_mask, acc_magnitude
```

#### **é¢‘åŸŸæ£€æµ‹æ³•**
```python
def frequency_domain_detection(acc_data, fs=100, low_freq=0.5, high_freq=10):
    """
    é¢‘åŸŸè¿åŠ¨æ£€æµ‹
    
    åŸç†: åˆ†æåŠ é€Ÿåº¦ä¿¡å·çš„é¢‘åŸŸç‰¹å¾ï¼Œè¿åŠ¨é€šå¸¸åœ¨é«˜é¢‘æ®µ
    ä¼˜ç‚¹: èƒ½åŒºåˆ†ä¸åŒç±»å‹çš„è¿åŠ¨
    ç¼ºç‚¹: éœ€è¦FFTè®¡ç®—ï¼Œå®æ—¶æ€§å·®
    """
    acc_magnitude = np.sqrt(acc_data['ax']**2 + acc_data['ay']**2 + acc_data['az']**2)
    
    # è®¡ç®—åŠŸç‡è°±å¯†åº¦
    f, Pxx = signal.welch(acc_magnitude, fs, nperseg=256)
    
    # è®¡ç®—é«˜é¢‘èƒ½é‡æ¯”ä¾‹
    freq_mask = (f >= low_freq) & (f <= high_freq)
    high_freq_energy = np.sum(Pxx[freq_mask])
    total_energy = np.sum(Pxx)
    
    # è¿åŠ¨æŒ‡æ ‡
    motion_index = high_freq_energy / total_energy
    
    return motion_index, f, Pxx
```

### 2. **è¿åŠ¨ä¼ªå½±å»é™¤æ–¹æ³•**

#### **æ’å€¼æ³•**
```python
def interpolation_removal(ppg_signal, motion_mask, method='linear'):
    """
    åŸºäºæ’å€¼çš„è¿åŠ¨ä¼ªå½±å»é™¤
    
    åŸç†: ç”¨è¿åŠ¨æ®µå‰åçš„æœ‰æ•ˆæ•°æ®æ’å€¼å¡«å……è¿åŠ¨æ®µ
    ä¼˜ç‚¹: ç®€å•æœ‰æ•ˆï¼Œä¿æŒä¿¡å·è¿ç»­æ€§
    ç¼ºç‚¹: å¯èƒ½äº§ç”Ÿä¸è‡ªç„¶çš„ä¿¡å·
    """
    ppg_cleaned = ppg_signal.copy()
    
    if np.any(motion_mask):
        # æ‰¾åˆ°è¿ç»­çš„è¿åŠ¨æ®µ
        motion_changes = np.diff(np.concatenate([[False], motion_mask, [False]]))
        motion_starts = np.where(motion_changes)[0][::2]
        motion_ends = np.where(motion_changes)[0][1::2]
        
        for start, end in zip(motion_starts, motion_ends):
            if start < len(ppg_signal) and end <= len(ppg_signal):
                # è·å–è¿åŠ¨æ®µå‰åçš„æœ‰æ•ˆæ•°æ®
                pre_motion = ppg_signal[max(0, start-50):start]
                post_motion = ppg_signal[end:min(len(ppg_signal), end+50)]
                
                if len(pre_motion) > 0 and len(post_motion) > 0:
                    # æ’å€¼
                    motion_indices = np.arange(start, end)
                    ppg_cleaned[motion_indices] = np.interp(
                        motion_indices, 
                        np.concatenate([np.arange(max(0, start-50), start),
                                      np.arange(end, min(len(ppg_signal), end+50))]), 
                        np.concatenate([pre_motion, post_motion])
                    )
    
    return ppg_cleaned
```

#### **æ ·æ¡æ’å€¼æ³•**
```python
def spline_interpolation_removal(ppg_signal, motion_mask):
    """
    åŸºäºæ ·æ¡æ’å€¼çš„è¿åŠ¨ä¼ªå½±å»é™¤
    
    åŸç†: ä½¿ç”¨ä¸‰æ¬¡æ ·æ¡æ’å€¼ï¼Œæ›´å¹³æ»‘è‡ªç„¶
    ä¼˜ç‚¹: æ’å€¼ç»“æœæ›´å¹³æ»‘ï¼Œæ›´è‡ªç„¶
    ç¼ºç‚¹: è®¡ç®—é‡è¾ƒå¤§ï¼Œå¯èƒ½è¿‡æ‹Ÿåˆ
    """
    from scipy.interpolate import CubicSpline
    
    ppg_cleaned = ppg_signal.copy()
    
    if np.any(motion_mask):
        motion_changes = np.diff(np.concatenate([[False], motion_mask, [False]]))
        motion_starts = np.where(motion_changes)[0][::2]
        motion_ends = np.where(motion_changes)[0][1::2]
        
        for start, end in zip(motion_starts, motion_ends):
            if start < len(ppg_signal) and end <= len(ppg_signal):
                pre_motion = ppg_signal[max(0, start-50):start]
                post_motion = ppg_signal[end:min(len(ppg_signal), end+50)]
                
                if len(pre_motion) > 0 and len(post_motion) > 0:
                    try:
                        pre_indices = np.arange(max(0, start-50), start)
                        post_indices = np.arange(end, min(len(ppg_signal), end+50))
                        
                        # åˆ›å»ºæ ·æ¡æ’å€¼å‡½æ•°
                        all_indices = np.concatenate([pre_indices, post_indices])
                        all_values = np.concatenate([pre_motion, post_motion])
                        
                        if len(all_indices) > 3:
                            cs = CubicSpline(all_indices, all_values)
                            motion_indices = np.arange(start, end)
                            ppg_cleaned[motion_indices] = cs(motion_indices)
                    except:
                        # å¦‚æœæ ·æ¡æ’å€¼å¤±è´¥ï¼Œä½¿ç”¨çº¿æ€§æ’å€¼
                        motion_indices = np.arange(start, end)
                        ppg_cleaned[motion_indices] = np.interp(
                            motion_indices, 
                            np.concatenate([pre_indices, post_indices]), 
                            np.concatenate([pre_motion, post_motion])
                        )
    
    return ppg_cleaned
```

#### **è‡ªé€‚åº”æ»¤æ³¢æ³•**
```python
def adaptive_filter_removal(ppg_signal, acc_data, filter_length=32, mu=0.01):
    """
    åŸºäºè‡ªé€‚åº”æ»¤æ³¢çš„è¿åŠ¨ä¼ªå½±å»é™¤
    
    åŸç†: ä½¿ç”¨åŠ é€Ÿåº¦ä¿¡å·ä½œä¸ºå‚è€ƒï¼Œè‡ªé€‚åº”è°ƒæ•´æ»¤æ³¢å™¨
    ä¼˜ç‚¹: èƒ½é€‚åº”ä¸åŒçš„è¿åŠ¨æ¨¡å¼
    ç¼ºç‚¹: æ”¶æ•›é€Ÿåº¦æ…¢ï¼Œå‚æ•°æ•æ„Ÿ
    """
    # å½’ä¸€åŒ–ä¿¡å·
    ppg_norm = (ppg_signal - np.mean(ppg_signal)) / np.std(ppg_signal)
    acc_norm = (acc_data - np.mean(acc_data)) / np.std(acc_data)
    
    # åˆå§‹åŒ–æ»¤æ³¢å™¨ç³»æ•°
    w = np.zeros(filter_length)
    
    # LMSè‡ªé€‚åº”ç®—æ³•
    filtered_signal = np.zeros_like(ppg_norm)
    for n in range(filter_length, len(ppg_norm)):
        x = acc_norm[n-filter_length:n]
        d = ppg_norm[n]
        y = np.dot(w, x)
        e = d - y
        w = w + mu * e * x
        filtered_signal[n] = y
    
    # å‰filter_lengthä¸ªç‚¹ç”¨åŸå§‹ä¿¡å·
    filtered_signal[:filter_length] = ppg_norm[:filter_length]
    
    # åå½’ä¸€åŒ–
    filtered_signal = filtered_signal * np.std(ppg_signal) + np.mean(ppg_signal)
    
    return filtered_signal
```

### 3. **å½¢æ€å­¦å¤„ç†æ–¹æ³•**

#### **å¼€è¿ç®—å’Œé—­è¿ç®—**
```python
def morphological_processing(motion_mask, open_size=5, close_size=10):
    """
    å½¢æ€å­¦å¤„ç†è¿åŠ¨æ©ç 
    
    åŸç†: ä½¿ç”¨å¼€è¿ç®—å»é™¤å­¤ç«‹ç‚¹ï¼Œé—­è¿ç®—è¿æ¥æ–­å¼€çš„æ®µ
    ä¼˜ç‚¹: èƒ½æœ‰æ•ˆå»é™¤å™ªå£°ï¼Œè¿æ¥æ–­å¼€çš„è¿åŠ¨æ®µ
    ç¼ºç‚¹: å¯èƒ½æ”¹å˜è¿åŠ¨æ®µçš„å½¢çŠ¶
    """
    from scipy.ndimage import binary_opening, binary_closing
    
    # å¼€è¿ç®—ï¼šå»é™¤å­¤ç«‹çš„è¿åŠ¨ç‚¹
    opened = binary_opening(motion_mask, structure=np.ones(open_size))
    
    # é—­è¿ç®—ï¼šè¿æ¥æ–­å¼€çš„è¿åŠ¨æ®µ
    closed = binary_closing(opened, structure=np.ones(close_size))
    
    return closed
```

### 4. **ä¿¡å·è´¨é‡è¯„ä¼°**

#### **ä¿¡å™ªæ¯”è®¡ç®—**
```python
def calculate_snr_with_acc(ppg_signal, acc_data, motion_mask):
    """
    åŸºäºåŠ é€Ÿåº¦ä¿¡æ¯çš„ä¿¡å™ªæ¯”è®¡ç®—
    
    åŸç†: åˆ†åˆ«è®¡ç®—é™æ­¢æ®µå’Œè¿åŠ¨æ®µçš„ä¿¡å·è´¨é‡
    ä¼˜ç‚¹: èƒ½åæ˜ è¿åŠ¨å¯¹ä¿¡å·è´¨é‡çš„å½±å“
    ç¼ºç‚¹: éœ€è¦å‡†ç¡®çš„è¿åŠ¨æ£€æµ‹
    """
    # åˆ†ç¦»é™æ­¢æ®µå’Œè¿åŠ¨æ®µ
    static_signal = ppg_signal[~motion_mask]
    motion_signal = ppg_signal[motion_mask]
    
    if len(static_signal) > 0 and len(motion_signal) > 0:
        # è®¡ç®—é™æ­¢æ®µå’Œè¿åŠ¨æ®µçš„åŠŸç‡
        static_power = np.mean(static_signal**2)
        motion_power = np.mean(motion_signal**2)
        
        # ä¿¡å™ªæ¯” = é™æ­¢æ®µåŠŸç‡ / è¿åŠ¨æ®µåŠŸç‡
        snr = 10 * np.log10(static_power / motion_power)
        
        return snr, static_power, motion_power
    
    return None, None, None
```

#### **è¿åŠ¨å¼ºåº¦æŒ‡æ ‡**
```python
def motion_intensity_index(acc_data, window_size=100):
    """
    è¿åŠ¨å¼ºåº¦æŒ‡æ ‡è®¡ç®—
    
    åŸç†: è®¡ç®—åŠ é€Ÿåº¦ä¿¡å·çš„æ–¹å·®ä½œä¸ºè¿åŠ¨å¼ºåº¦æŒ‡æ ‡
    ä¼˜ç‚¹: ç®€å•ç›´è§‚ï¼Œè®¡ç®—å¿«é€Ÿ
    ç¼ºç‚¹: å¯¹å™ªå£°æ•æ„Ÿ
    """
    acc_magnitude = np.sqrt(acc_data['ax']**2 + acc_data['ay']**2 + acc_data['az']**2)
    
    # æ»‘åŠ¨çª—å£è®¡ç®—è¿åŠ¨å¼ºåº¦
    motion_intensity = np.zeros_like(acc_magnitude)
    for i in range(len(acc_magnitude)):
        start_idx = max(0, i - window_size // 2)
        end_idx = min(len(acc_magnitude), i + window_size // 2)
        motion_intensity[i] = np.var(acc_magnitude[start_idx:end_idx])
    
    return motion_intensity
```

## ğŸ¯ æ¨èä½¿ç”¨ç­–ç•¥

### 1. **å®æ—¶åº”ç”¨**
- **è¿åŠ¨æ£€æµ‹**: é˜ˆå€¼æ£€æµ‹æ³•ï¼ˆå¿«é€Ÿï¼‰
- **ä¼ªå½±å»é™¤**: çº¿æ€§æ’å€¼æ³•ï¼ˆç®€å•ï¼‰
- **è´¨é‡è¯„ä¼°**: è¿åŠ¨å¼ºåº¦æŒ‡æ ‡

### 2. **ç¦»çº¿åˆ†æ**
- **è¿åŠ¨æ£€æµ‹**: æ»‘åŠ¨çª—å£æ£€æµ‹æ³•ï¼ˆå‡†ç¡®ï¼‰
- **ä¼ªå½±å»é™¤**: æ ·æ¡æ’å€¼æ³•ï¼ˆå¹³æ»‘ï¼‰
- **è´¨é‡è¯„ä¼°**: ä¿¡å™ªæ¯”è®¡ç®—

### 3. **é«˜ç²¾åº¦è¦æ±‚**
- **è¿åŠ¨æ£€æµ‹**: é¢‘åŸŸæ£€æµ‹æ³•ï¼ˆç²¾ç¡®ï¼‰
- **ä¼ªå½±å»é™¤**: è‡ªé€‚åº”æ»¤æ³¢æ³•ï¼ˆæ™ºèƒ½ï¼‰
- **è´¨é‡è¯„ä¼°**: å¤šæŒ‡æ ‡ç»¼åˆè¯„ä¼°

## ğŸ”§ å‚æ•°è°ƒä¼˜å»ºè®®

### 1. **è¿åŠ¨æ£€æµ‹å‚æ•°**
```python
# é˜ˆå€¼æ£€æµ‹
threshold_factor = 1.5  # é™æ­¢å®éªŒ
threshold_factor = 2.0  # è½»åº¦è¿åŠ¨å®éªŒ
threshold_factor = 2.5  # å‰§çƒˆè¿åŠ¨å®éªŒ

# æ»‘åŠ¨çª—å£
window_size = 50   # å¿«é€Ÿå˜åŒ–
window_size = 100  # ä¸€èˆ¬æƒ…å†µ
window_size = 200  # ç¼“æ…¢å˜åŒ–
```

### 2. **ä¼ªå½±å»é™¤å‚æ•°**
```python
# æ’å€¼èŒƒå›´
interpolation_range = 25   # ä¿å®ˆ
interpolation_range = 50   # å¹³è¡¡
interpolation_range = 100  # æ¿€è¿›

# è‡ªé€‚åº”æ»¤æ³¢
filter_length = 16  # å¿«é€Ÿæ”¶æ•›
filter_length = 32  # å¹³è¡¡
filter_length = 64  # é«˜ç²¾åº¦
mu = 0.005         # ç¨³å®š
mu = 0.01          # å¹³è¡¡
mu = 0.02          # å¿«é€Ÿ
```

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. **è¿åŠ¨æ£€æµ‹**: "Motion artifact detection and removal in PPG signals using accelerometer data"
2. **æ’å€¼æ–¹æ³•**: "Interpolation techniques for motion artifact removal in biomedical signals"
3. **è‡ªé€‚åº”æ»¤æ³¢**: "Adaptive filtering for motion artifact removal in wearable PPG sensors"
4. **å½¢æ€å­¦å¤„ç†**: "Morphological operations in signal processing applications"
5. **ä¿¡å·è´¨é‡è¯„ä¼°**: "Signal quality assessment in wearable health monitoring systems"

## ğŸ”® æœªæ¥å‘å±•æ–¹å‘

1. **æœºå™¨å­¦ä¹ **: ä½¿ç”¨æ·±åº¦å­¦ä¹ è‡ªåŠ¨æ£€æµ‹è¿åŠ¨æ¨¡å¼
2. **å¤šä¼ æ„Ÿå™¨èåˆ**: ç»“åˆé™€èºä»ªã€ç£åŠ›è®¡ç­‰ä¼ æ„Ÿå™¨
3. **ä¸ªæ€§åŒ–æ¨¡å‹**: æ ¹æ®ä¸ªä½“ç‰¹å¾è‡ªé€‚åº”è°ƒæ•´å‚æ•°
4. **å®æ—¶ä¼˜åŒ–**: é™ä½è®¡ç®—å¤æ‚åº¦ï¼Œæé«˜å®æ—¶æ€§
